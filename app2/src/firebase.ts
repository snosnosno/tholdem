// Firebase Ï¥àÍ∏∞Ìôî Î∞è Ïù∏Ï¶ù/DB Ïù∏Ïä§ÌÑ¥Ïä§ export
import { initializeApp } from "firebase/app";
import { logger } from './utils/logger';
import { getAuth, connectAuthEmulator } from "firebase/auth";
import {
  getFirestore,
  doc,
  collection,
  getDocs,
  writeBatch,
  query,
  where,
  orderBy,
  limit,
  startAfter,
  Timestamp,
  Query,
  connectFirestoreEmulator
} from "firebase/firestore";
import { getFunctions, connectFunctionsEmulator } from "firebase/functions";
// StorageÎäî ÎèôÏ†Å importÎ•º ÏúÑÌï¥ ÏßÅÏ†ë importÌïòÏßÄ ÏïäÏùå

import type { JobPostingFilters } from './hooks/useJobPostings';
import type { QueryConstraint as FirestoreQueryConstraint, DocumentSnapshot } from 'firebase/firestore';
// Import centralized config
import { firebaseConfig, emulatorConfig, validateConfig } from './config/firebase.config';

// Validate configuration on load
if (!validateConfig()) {
  logger.warn('Firebase configuration validation failed', {
    component: 'firebase.ts'
  });
}

const app = initializeApp(firebaseConfig);
export { app }; // Export app for Firebase Performance

export const auth = getAuth(app);

// Connect to Firebase Emulators for local development
const { useEmulator: isEmulator } = emulatorConfig;

// Initialize Firestore with proper settings based on environment
let db: ReturnType<typeof getFirestore>;

try {
  if (isEmulator) {
    // For emulator environment, use getFirestore
    db = getFirestore(app);
    logger.info('Firestore initialized for emulator environment', {
      component: 'firebase',
      environment: 'emulator'
    });
  } else {
    // For production, also use getFirestore for now
    // Firebase v11 cache settings are still experimental
    db = getFirestore(app);
    logger.info('Firestore initialized for production environment', {
      component: 'firebase',
      environment: 'production'
    });
  }
} catch (error) {
  // Fallback to getFirestore if initialization fails
  db = getFirestore(app);
  logger.warn('Fallback to getFirestore due to initialization error', {
    component: 'firebase',
    errorInfo: String(error)
  });
}

export { db };

// Initialize Functions
export const functions = getFunctions(app);

// StorageÎäî ÎèôÏ†Å Î°úÎî©ÏùÑ ÏúÑÌï¥ Î≥ÑÎèÑ Ïú†Ìã∏Î¶¨Ìã∞ ÏÇ¨Ïö©

if (isEmulator) {
  // Connect Functions Emulator
  connectFunctionsEmulator(functions, 'localhost', 5001);
  logger.info('Functions emulator connected', { data: { port: 5001 } });
  try {
    // Connect Auth Emulator with additional security options
    connectAuthEmulator(auth, 'http://localhost:9099', {
      disableWarnings: true,
      // Force emulator mode to bypass token endpoint issues
    });

    // Set additional emulator-specific settings
    if (typeof window !== 'undefined') {
      // Disable token refresh for emulator mode
      window.__FIREBASE_DEFAULTS__ = {
        ...(window.__FIREBASE_DEFAULTS__ || {}),
        emulatorHosts: {
          auth: 'localhost:9099',
          firestore: 'localhost:8080'
        }
      };
    }
  } catch (error) {
    // Emulator already connected or unavailable
  }

  try {
    // Connect Firestore Emulator
    connectFirestoreEmulator(db, 'localhost', 8080);
  } catch (error) {
    // Emulator already connected or unavailable
  }
}

export const setupTestData = async () => {
  const tablesCollectionRef = collection(db, 'tables');
  const snapshot = await getDocs(tablesCollectionRef);

  if (!snapshot.empty) {
    return 'SKIPPED';
  }

  const batch = writeBatch(db);

  // Create 10 tables
  for (let i = 1; i <= 10; i++) {
    const tableRef = doc(collection(db, 'tables'));
    batch.set(tableRef, {
      tableNumber: i,
      seats: Array(9).fill(null),
    });
  }

  // Create 80 participants
  for (let i = 1; i <= 80; i++) {
    const participantRef = doc(collection(db, 'participants'));
    batch.set(participantRef, {
      name: `Participant ${i}`,
      chips: 10000,
      buyInStatus: 'paid',
      status: 'active',
    });
  }

  try {
    await batch.commit();
    return 'SUCCESS';
  } catch (error) {
    logger.error('Error writing test data: ', error instanceof Error ? error : new Error(String(error)), { component: 'firebase' });
    return 'ERROR';
  }
};

// üö´ DEPRECATED: promoteToStaff Ìï®Ïàò ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî
// persons Ïª¨Î†âÏÖòÏùÄ WorkLogÏùò staffInfo ÌïÑÎìúÎ°ú ÏôÑÏ†ÑÌûà ÌÜµÌï©ÎêòÏóàÏäµÎãàÎã§.
// Ïù¥ Ìï®ÏàòÎäî Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏúºÎ©∞, WorkLog ÏÉùÏÑ±ÏùÄ useApplicantActionsÏóêÏÑú ÏßÅÏ†ë Ï≤òÎ¶¨Îê©ÎãàÎã§.
export const promoteToStaff = async (
  documentId: string,
  userName: string,
  jobRole: string,
  postingId: string,
  _managerId: string,
  _assignedRole?: string,
  _assignedTime?: string,
  _email?: string,
  _phone?: string,
  _assignedDate?: string,
  _actualUserId?: string
) => {
  // üö´ Ìï®Ïàò ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî - Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
  logger.warn('‚ö†Ô∏è promoteToStaff Ìï®ÏàòÎäî deprecatedÎêòÏóàÏäµÎãàÎã§. WorkLog ÏÉùÏÑ±ÏùÄ useApplicantActionsÏóêÏÑú ÏßÅÏ†ë Ï≤òÎ¶¨Îê©ÎãàÎã§.', {
    component: 'firebase',
    data: { documentId, postingId }
  });
  
  // Îçî Ïù¥ÏÉÅ WorkLogÎ•º ÏÉùÏÑ±ÌïòÏßÄ ÏïäÍ≥† Ï¶âÏãú Î∞òÌôò
  return Promise.resolve();
};

interface PaginationOptions {
  limit?: number;
  startAfterDoc?: DocumentSnapshot;
}

// Build filtered query for job postings - COMPREHENSIVE INDEX VERSION
export const buildFilteredQuery = (
  filters: JobPostingFilters, 
  pagination?: PaginationOptions
): Query => {
  const jobPostingsRef = collection(db, 'jobPostings');
  const queryConstraints: FirestoreQueryConstraint[] = [];
  
  
  // Always filter for open status
  queryConstraints.push(where('status', '==', 'open'));
  
  // Handle search queries with location/type support
  if (filters.searchTerms && filters.searchTerms.length > 0) {
    queryConstraints.push(where('searchIndex', 'array-contains-any', filters.searchTerms));
    
    // Add location filter if specified (has index: status + searchIndex + location + createdAt)
    if (filters.location && filters.location !== 'all') {
      queryConstraints.push(where('location', '==', filters.location));
    }
    // Add type filter if specified and no location (has index: status + searchIndex + type + createdAt)
    else if (filters.type && filters.type !== 'all') {
      queryConstraints.push(where('type', '==', filters.type));
    }
    
    // Always use createdAt ordering for search results
    queryConstraints.push(orderBy('createdAt', 'desc'));
  } 
  // Handle date-based queries (prioritized because of range query limitations)
  else if (filters.startDate) {
    
    // Create date at start of day to match job postings
    const filterDate = new Date(filters.startDate);
    filterDate.setHours(0, 0, 0, 0);
    const startDateTimestamp = Timestamp.fromDate(filterDate);
    
    queryConstraints.push(where('startDate', '>=', startDateTimestamp));
    
    // Priority: Role filter first (if specified), then location/type
    // Note: Firebase doesn't allow inequality + array-contains in same query
    // So we prioritize role filter and do client-side filtering for others
    if (filters.role && filters.role !== 'all') {
      queryConstraints.push(where('requiredRoles', 'array-contains', filters.role));
      // Note: location/type will be filtered client-side
    }
    // Add location filter if no role filter (has index: status + location + startDate)
    else if (filters.location && filters.location !== 'all') {
      queryConstraints.push(where('location', '==', filters.location));
    }
    // Add type filter if no role/location filter (has index: status + type + startDate)
    else if (filters.type && filters.type !== 'all') {
      queryConstraints.push(where('type', '==', filters.type));
    }
    
    // Use startDate ordering for date-filtered queries
    queryConstraints.push(orderBy('startDate', 'asc'));
  }
  // Handle non-date queries
  else {
    // Add location filter
    if (filters.location && filters.location !== 'all') {
      queryConstraints.push(where('location', '==', filters.location));
    }
    
    // Add type filter
    if (filters.type && filters.type !== 'all') {
      queryConstraints.push(where('type', '==', filters.type));
    }
    
    // Add role filter
    if (filters.role && filters.role !== 'all') {
      queryConstraints.push(where('requiredRoles', 'array-contains', filters.role));
    }
    
    // Use createdAt ordering for non-date queries
    queryConstraints.push(orderBy('createdAt', 'desc'));
  }
  
  // Add startAfter for pagination if provided
  if (pagination?.startAfterDoc) {
    queryConstraints.push(startAfter(pagination.startAfterDoc));
  }
  
  // Add limit (default 20 for regular queries, customizable for infinite scroll)
  queryConstraints.push(limit(pagination?.limit || 20));
  
  
  return query(jobPostingsRef, ...queryConstraints);
};

// Migration function to add searchIndex to existing job postings
export const migrateJobPostingsSearchIndex = async (): Promise<void> => {
  
  try {
    const jobPostingsRef = collection(db, 'jobPostings');
    const snapshot = await getDocs(jobPostingsRef);
    
    const batch = writeBatch(db);
    let updateCount = 0;
    
    snapshot.forEach((docSnapshot) => {
      const data = docSnapshot.data();
      
      // Skip if searchIndex already exists
      if (data.searchIndex) {
        return;
      }
      
      const title = data.title || '';
      const description = data.description || '';
      
      // Generate search index
      const searchIndex = generateSearchIndexForJobPosting(title, description);
      
      // Update document
      const docRef = doc(db, 'jobPostings', docSnapshot.id);
      batch.update(docRef, { searchIndex });
      updateCount++;
    });
    
    if (updateCount > 0) {
      await batch.commit();
    }
  } catch (error) {
    logger.error('Error during searchIndex migration:', error instanceof Error ? error : new Error(String(error)), { component: 'firebase' });
    throw error;
  }
};

// Migration function to add requiredRoles to existing job postings
export const migrateJobPostingsRequiredRoles = async (): Promise<void> => {
  
  try {
    const jobPostingsRef = collection(db, 'jobPostings');
    const snapshot = await getDocs(jobPostingsRef);
    
    const batch = writeBatch(db);
    let updateCount = 0;
    
    snapshot.forEach((docSnapshot) => {
      const data = docSnapshot.data();
      
      // Skip if requiredRoles already exists
      if (data.requiredRoles && Array.isArray(data.requiredRoles)) {
        return;
      }
      
      // Extract roles from dateSpecificRequirements
      const dateSpecificRequirements = data.dateSpecificRequirements || [];
      const requiredRoles = Array.from(new Set(
        dateSpecificRequirements.flatMap((dateReq: { timeSlots?: Array<{ roles?: Array<{ name: string }> }> }) => {
          if (dateReq.timeSlots && Array.isArray(dateReq.timeSlots)) {
            return dateReq.timeSlots.flatMap((ts: { roles?: Array<{ name: string }> }) => {
              if (ts.roles && Array.isArray(ts.roles)) {
                return ts.roles.map((r: { name: string }) => r.name);
              }
              return [];
            });
          }
          return [];
        })
      ));
      
      
      // Update document
      const docRef = doc(db, 'jobPostings', docSnapshot.id);
      batch.update(docRef, { requiredRoles });
      updateCount++;
    });
    
    if (updateCount > 0) {
      await batch.commit();
    }
  } catch (error) {
    logger.error('Error during requiredRoles migration:', error instanceof Error ? error : new Error(String(error)), { component: 'firebase' });
    throw error;
  }
};

// Migration function to convert string dates to Timestamps
export const migrateJobPostingsDateFormat = async (): Promise<void> => {
  
  try {
    const jobPostingsRef = collection(db, 'jobPostings');
    const snapshot = await getDocs(jobPostingsRef);
    
    const batch = writeBatch(db);
    let updateCount = 0;
    
    snapshot.forEach((docSnapshot) => {
      const data = docSnapshot.data();
      
      // Check if startDate is a string and needs conversion
      if (data.startDate && typeof data.startDate === 'string') {
        const dateObj = new Date(data.startDate);
        if (!isNaN(dateObj.getTime())) {
          const startDateTimestamp = Timestamp.fromDate(dateObj);
          
          // Update document
          const docRef = doc(db, 'jobPostings', docSnapshot.id);
          batch.update(docRef, { startDate: startDateTimestamp });
          updateCount++;
        }
      }
      
      // Also handle endDate if it exists
      if (data.endDate && typeof data.endDate === 'string') {
        const dateObj = new Date(data.endDate);
        if (!isNaN(dateObj.getTime())) {
          const endDateTimestamp = Timestamp.fromDate(dateObj);
          
          // Update document
          const docRef = doc(db, 'jobPostings', docSnapshot.id);
          batch.update(docRef, { endDate: endDateTimestamp });
          updateCount++;
        }
      }
    });
    
    if (updateCount > 0) {
      await batch.commit();
    }
  } catch (error) {
    logger.error('Error during date format migration:', error instanceof Error ? error : new Error(String(error)), { component: 'firebase' });
    throw error;
  }
};

// Helper function to generate search index for job postings
const generateSearchIndexForJobPosting = (title: string, description: string): string[] => {
  const text = `${title} ${description}`.toLowerCase();
  const words = text
    .replace(/[^\w\sÍ∞Ä-Ìû£]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 1);
  
  return Array.from(new Set(words));
};

// Run all migrations for job postings
export const runJobPostingsMigrations = async (): Promise<void> => {
  
  try {
    await migrateJobPostingsRequiredRoles();
    await migrateJobPostingsDateFormat();
    await migrateJobPostingsSearchIndex();
  } catch (error) {
    logger.error('??Migration failed:', error instanceof Error ? error : new Error(String(error)), { component: 'firebase' });
    throw error;
  }
};
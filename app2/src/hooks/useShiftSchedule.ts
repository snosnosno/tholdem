import { useState, useEffect, useCallback, useMemo } from 'react';\nimport { db } from '../firebase';\nimport { collection, doc, onSnapshot, query, where, updateDoc, setDoc, serverTimestamp, Timestamp, addDoc, getDocs } from 'firebase/firestore';\nimport { generateTimeSlots as utilGenerateTimeSlots, convertAssignmentData } from '../utils/timeUtils';\nimport { validateSchedule, ValidationResult, ValidationSettings, DEFAULT_VALIDATION_SETTINGS, DealerSchedule } from '../utils/shiftValidation';\n\n// ShiftSchedule 데이터 구조 정의\nexport interface ShiftSchedule {\n  id: string;\n  eventId: string;\n  date: string; // YYYY-MM-DD 형식\n  timeInterval: number; // 분 단위 (10, 20, 30, 60)\n  startTime: string; // HH:MM 형식\n  endTime: string; // HH:MM 형식\n  scheduleData: {\n    [dealerId: string]: {\n      dealerName: string;\n      startTime: string; // 개인별 출근시간\n      assignments: { [timeSlot: string]: string }; // \"Table1\" | \"Table2\" | \"휴식\" | \"대기\"\n    }\n  };\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\n// 딜러 정보 (기존 Staff와 호환)\nexport interface ShiftDealer {\n  id: string;\n  name: string;\n  role: string;\n  status?: 'on_table' | 'available' | 'on_break';\n  assignedTableId?: string;\n  photoURL?: string;\n}\n\n// 근무기록 데이터 구조 (기존 QR 출퇴근과 구분)\nexport interface WorkLog {\n  id?: string;\n  eventId: string;\n  date: string; // YYYY-MM-DD\n  dealerId: string;\n  dealerName: string;\n  type: 'schedule' | 'qr'; // 스케줄 기반 vs QR 실제 기록\n  scheduledStartTime: string; // 스케줄상 출근시간\n  scheduledEndTime: string; // 스케줄상 퇴근시간\n  actualStartTime?: string; // QR 실제 출근시간 (옵션)\n  actualEndTime?: string; // QR 실제 퇴근시간 (옵션)\n  totalWorkMinutes: number; // 총 근무시간 (분)\n  totalBreakMinutes: number; // 총 휴식시간 (분)\n  tableAssignments: string[]; // 배정된 테이블 목록\n  status: 'scheduled' | 'in_progress' | 'completed'; // 상태\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\n// 시간 슬롯 생성 유틸리티 (개선된 버전 사용)\nexport const generateTimeSlots = utilGenerateTimeSlots;\n\nexport const useShiftSchedule = (eventId?: string, date?: string) => {\n  const [schedule, setSchedule] = useState<ShiftSchedule | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);\n  const [validationSettings, setValidationSettings] = useState<ValidationSettings>(DEFAULT_VALIDATION_SETTINGS);\n\n  // 스케줄 문서 ID 생성\n  const scheduleId = eventId && date ? `${eventId}_${date}` : null;\n\n  // Firebase 실시간 리스너\n  useEffect(() => {\n    if (!scheduleId) {\n      setSchedule(null);\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true);\n    const scheduleRef = doc(db, 'shiftSchedules', scheduleId);\n    \n    const unsubscribe = onSnapshot(\n      scheduleRef,\n      (docSnapshot) => {\n        if (docSnapshot.exists()) {\n          setSchedule({ id: docSnapshot.id, ...docSnapshot.data() } as ShiftSchedule);\n        } else {\n          setSchedule(null);\n        }\n        setLoading(false);\n        setError(null);\n      },\n      (err) => {\n        console.error('Error fetching shift schedule:', err);\n        setError(err);\n        setLoading(false);\n      }\n    );\n\n    return () => unsubscribe();\n  }, [scheduleId]);\n\n  // 새로운 스케줄 생성\n  const createSchedule = useCallback(async (\n    eventId: string,\n    date: string,\n    timeInterval: number = 30,\n    startTime: string = '09:00',\n    endTime: string = '18:00'\n  ) => {\n    try {\n      const newScheduleId = `${eventId}_${date}`;\n      const newSchedule: Omit<ShiftSchedule, 'id'> = {\n        eventId,\n        date,\n        timeInterval,\n        startTime,\n        endTime,\n        scheduleData: {},\n        createdAt: serverTimestamp() as Timestamp,\n        updatedAt: serverTimestamp() as Timestamp,\n      };\n\n      const scheduleRef = doc(db, 'shiftSchedules', newScheduleId);\n      await setDoc(scheduleRef, newSchedule);\n      \n      return newScheduleId;\n    } catch (err) {\n      console.error('Error creating schedule:', err);\n      setError(err as Error);\n      throw err;\n    }\n  }, []);\n\n  // 딜러 할당 업데이트\n  const updateDealerAssignment = useCallback(async (\n    dealerId: string,\n    timeSlot: string,\n    assignment: string\n  ) => {\n    if (!scheduleId || !schedule) return;\n\n    try {\n      const scheduleRef = doc(db, 'shiftSchedules', scheduleId);\n      const updatePath = `scheduleData.${dealerId}.assignments.${timeSlot}`;\n      \n      await updateDoc(scheduleRef, {\n        [updatePath]: assignment,\n        updatedAt: serverTimestamp(),\n      });\n    } catch (err) {\n      console.error('Error updating dealer assignment:', err);\n      setError(err as Error);\n      throw err;\n    }\n  }, [scheduleId, schedule]);\n\n  // 딜러 추가\n  const addDealer = useCallback(async (\n    dealerId: string,\n    dealerName: string,\n    startTime: string = '09:00'\n  ) => {\n    if (!scheduleId) return;\n\n    try {\n      const scheduleRef = doc(db, 'shiftSchedules', scheduleId);\n      const dealerData = {\n        dealerName,\n        startTime,\n        assignments: {},\n      };\n\n      await updateDoc(scheduleRef, {\n        [`scheduleData.${dealerId}`]: dealerData,\n        updatedAt: serverTimestamp(),\n      });\n    } catch (err) {\n      console.error('Error adding dealer:', err);\n      setError(err as Error);\n      throw err;\n    }\n  }, [scheduleId]);\n  \n  // 시간 간격 및 시간 범위 업데이트\n  const updateScheduleSettings = useCallback(async (\n    newInterval?: number,\n    newStartTime?: string,\n    newEndTime?: string\n  ) => {\n    if (!scheduleId || !schedule) return;\n  \n    try {\n      const scheduleRef = doc(db, 'shiftSchedules', scheduleId);\n      const updates: any = {\n        updatedAt: serverTimestamp(),\n      };\n  \n      // 시간 간격 변경 시 기존 데이터 변환\n      if (newInterval && newInterval !== schedule.timeInterval) {\n        updates.timeInterval = newInterval;\n        \n        // 기존 할당 데이터 변환\n        const convertedScheduleData: any = {};\n        Object.entries(schedule.scheduleData).forEach(([dealerId, dealerData]) => {\n          convertedScheduleData[dealerId] = {\n            ...dealerData,\n            assignments: convertAssignmentData(\n              dealerData.assignments,\n              schedule.timeInterval,\n              newInterval,\n              newStartTime || schedule.startTime,\n              newEndTime || schedule.endTime\n            )\n          };\n        });\n        updates.scheduleData = convertedScheduleData;\n      }\n  \n      if (newStartTime) updates.startTime = newStartTime;\n      if (newEndTime) updates.endTime = newEndTime;\n  \n      await updateDoc(scheduleRef, updates);\n    } catch (err) {\n      console.error('Error updating schedule settings:', err);\n      setError(err as Error);\n      throw err;\n    }\n  }, [scheduleId, schedule]);\n\n  // 시간 슬롯 생성 (메모이제이션)\n  const timeSlots = useMemo(() => {\n    if (!schedule) return [];\n    return generateTimeSlots(schedule.startTime, schedule.endTime, schedule.timeInterval);\n  }, [schedule?.startTime, schedule?.endTime, schedule?.timeInterval]);\n\n  // 딜러 목록 (메모이제이션)\n  const dealers = useMemo(() => {\n    if (!schedule) return [];\n    return Object.entries(schedule.scheduleData).map(([id, data]) => ({\n      id,\n      ...data,\n    }));\n  }, [schedule?.scheduleData]);\n\n  // 스케줄 검증 함수\n  const validateCurrentSchedule = useCallback(() => {\n    if (!schedule || !timeSlots.length || !dealers.length) {\n      setValidationResult(null);\n      return null;\n    }\n\n    const dealerSchedules: DealerSchedule[] = dealers.map(dealer => ({\n      id: dealer.id,\n      dealerName: dealer.dealerName,\n      startTime: dealer.startTime,\n      assignments: dealer.assignments,\n    }));\n\n    const result = validateSchedule(dealerSchedules, timeSlots, validationSettings);\n    setValidationResult(result);\n    return result;\n  }, [schedule, timeSlots, dealers, validationSettings]);\n\n  // 검증 설정 업데이트\n  const updateValidationSettings = useCallback((newSettings: Partial<ValidationSettings>) => {\n    setValidationSettings(prev => ({ ...prev, ...newSettings }));\n  }, []);\n\n  // 스케줄 변경 시 자동 검증 (메모이제이션)\n  const autoValidationResult = useMemo(() => {\n    if (!schedule || !timeSlots.length || !dealers.length) return null;\n\n    const dealerSchedules: DealerSchedule[] = dealers.map(dealer => ({\n      id: dealer.id,\n      dealerName: dealer.dealerName,\n      startTime: dealer.startTime,\n      assignments: dealer.assignments,\n    }));\n\n    return validateSchedule(dealerSchedules, timeSlots, validationSettings);\n  }, [schedule?.scheduleData, timeSlots, validationSettings]);\n\n  // 자동 검증 결과를 상태에 반영\n  useEffect(() => {\n    setValidationResult(autoValidationResult);\n  }, [autoValidationResult]);\n\n  // 근무기록 자동 생성 함수\n  const generateWorkLogs = useCallback(async () => {\n    if (!schedule || !eventId || !date) {\n      throw new Error('스케줄, 이벤트 ID, 날짜 정보가 필요합니다.');\n    }\n\n    try {\n      const workLogsCollection = collection(db, 'workLogs');\n      const generatedLogs: Omit<WorkLog, 'id'>[] = [];\n\n      // 각 딜러별로 근무기록 생성\n      for (const dealer of dealers) {\n        const { id: dealerId, dealerName, startTime: dealerStartTime, assignments } = dealer;\n        \n        // 시간 슬롯별 할당 데이터 분석\n        let totalWorkMinutes = 0;\n        let totalBreakMinutes = 0;\n        const tableAssignments: string[] = [];\n        let actualStartTime: string | null = null;\n        let actualEndTime: string | null = null;\n\n        // 할당된 시간 슬롯들 순회\n        timeSlots.forEach(timeSlot => {\n          const assignment = assignments[timeSlot];\n          if (assignment && assignment !== '대기') {\n            if (!actualStartTime) actualStartTime = timeSlot;\n            actualEndTime = timeSlot;\n            \n            if (assignment === '휴식') {\n              totalBreakMinutes += schedule.timeInterval;\n            } else if (assignment.startsWith('T') || assignment.startsWith('Table')) {\n              totalWorkMinutes += schedule.timeInterval;\n              if (!tableAssignments.includes(assignment)) {\n                tableAssignments.push(assignment);\n              }\n            }\n          }\n        });\n\n        // 스케줄상 시작/종료 시간 계산\n        const scheduledStartTime = dealerStartTime;\n        const scheduledEndTime = actualEndTime || schedule.endTime;\n\n        const workLog: Omit<WorkLog, 'id'> = {\n          eventId,\n          date,\n          dealerId,\n          dealerName,\n          type: 'schedule',\n          scheduledStartTime,\n          scheduledEndTime,\n          totalWorkMinutes,\n          totalBreakMinutes,\n          tableAssignments,\n          status: 'scheduled',\n          createdAt: serverTimestamp() as Timestamp,\n          updatedAt: serverTimestamp() as Timestamp,\n        };\n\n        generatedLogs.push(workLog);\n      }\n\n      // Firestore에 일괄 저장\n      for (const log of generatedLogs) {\n        await addDoc(workLogsCollection, log);\n      }\n\n      console.log(`${generatedLogs.length}개의 근무기록이 생성되었습니다.`);\n      return generatedLogs;\n    } catch (error) {\n      console.error('근무기록 생성 중 오류:', error);\n      throw error;\n    }\n  }, [schedule, eventId, date, dealers, timeSlots]);\n\n  // 근무기록 존재 여부 확인 함수\n  const checkWorkLogsExist = useCallback(async () => {\n    if (!eventId || !date) return false;\n\n    try {\n      const workLogsQuery = query(\n        collection(db, 'workLogs'),\n        where('eventId', '==', eventId),\n        where('date', '==', date),\n        where('type', '==', 'schedule')\n      );\n      \n      const snapshot = await getDocs(workLogsQuery);\n      return !snapshot.empty;\n    } catch (error) {\n      console.error('근무기록 확인 중 오류:', error);\n      return false;\n    }\n  }, [eventId, date]);\n\n  return {\n    schedule,\n    loading,\n    error,\n    timeSlots,\n    dealers,\n    validationResult,\n    validationSettings,\n    createSchedule,\n    updateDealerAssignment,\n    addDealer,\n    updateScheduleSettings,\n    validateCurrentSchedule,\n    updateValidationSettings,\n    generateWorkLogs,\n    checkWorkLogsExist,\n  };\n};\n\nexport default useShiftSchedule;"